{
  "paths": {
    "/managedPolicy": {},
    "/managedPolicy/{id}": {},
    "/managedPolicyCondition": {},
    "/managedPolicyCondition/{id}": {},
    "/managedPolicyEvent": {},
    "/managedPolicyEvent/{id}": {},
    "/managedPolicyExpression": {},
    "/managedPolicyExpression/{id}": {},
    "/managedPolicyOperator": {},
    "/managedPolicyOperator/{id}": {},
    "/managedPolicyVariable": {},
    "/managedPolicyVariable/{id}": {},
    "/managedPolicyAction": {},
    "/managedPolicyAction/{id}": {},
    "/managedPolicyConstraint": {},
    "/managedPolicyConstraint/{id}": {},
    "/policyDomain": {},
    "/policyDomain/{id}": {},
    "/policyCatalog": {},
    "/policyCatalog/{id}": {}
  },
  "components": {
    "schemas": {
      "ManagedPolicy": {
        "description": "Managed Policy",
        "allOf": [
          {
            "$ref": "#/components/schemas/PolicyManagedEntity"
          },
          {
            "$ref": "#/components/schemas/Policy"
          }
        ],
        "discriminator": {
          "propertyName": "@type",
          "mapping": {
            "ManagedPolicy": "#/components/schemas/ManagedPolicy"
          }
        }
      },
      "PolicyManagedEntity": {
        "allOf": [
          {
            "$ref": "#/components/schemas/Entity"
          },
          {
            "description": "Fields required for managed (reusable) Policy entities",
            "properties": {
              "name": {
                "type": "string",
                "description": "Name of the Policy Entity"
              },
              "version": {
                "type": "string",
                "description": "Version of the Policy Entity"
              },
              "description": {
                "type": "string",
                "description": "Description of the Policy Entity"
              },
              "lifecycleState": {
                "type": "string",
                "description": "Lifecycle state of the Policy Entity",
                "enum": [
                  "inDesign",
                  "designed",
                  "active",
                  "retired",
                  "rejected"
                ]
              },
              "validFor": {
                "$ref": "#/components/schemas/TimePeriod"
              },
              "note": {
                "type": "array",
                "description": "Comments related to Policy Entity",
                "items": {
                  "$ref": "#/components/schemas/Note"
                }
              }
            }
          }
        ],
        "discriminator": {
          "propertyName": "@type",
          "mapping": {
            "PolicyManagedEntity": "#/components/schemas/PolicyManagedEntity",
            "PolicyDomain": "#/components/schemas/PolicyDomain",
            "PolicyCatalog": "#/components/schemas/PolicyCatalog",
            "ManagedPolicyVariable": "#/components/schemas/ManagedPolicyVariable",
            "ManagedPolicyOperator": "#/components/schemas/ManagedPolicyOperator",
            "ManagedPolicyExpression": "#/components/schemas/ManagedPolicyExpression",
            "ManagedPolicyEvent": "#/components/schemas/ManagedPolicyEvent",
            "ManagedPolicyConstraint": "#/components/schemas/ManagedPolicyConstraint",
            "ManagedPolicyCondition": "#/components/schemas/ManagedPolicyCondition",
            "ManagedPolicyAction": "#/components/schemas/ManagedPolicyAction",
            "ManagedPolicy": "#/components/schemas/ManagedPolicy"
          }
        }
      },
      "Policy": {
        "type": "object",
        "description": "Policy is a set of rules that are used to manage and control the state and state transitions of one or more managed objects.",
        "oneOf": [
          {
            "$ref": "#/components/schemas/PolicyRule"
          },
          {
            "$ref": "#/components/schemas/PolicySet"
          }
        ],
        "discriminator": {
          "propertyName": "@type",
          "mapping": {
            "PolicyRule": "#/components/schemas/PolicyRule",
            "PolicySet": "#/components/schemas/PolicySet"
          }
        }
      },
      
"PolicySet": {
        "allOf": [
          {
            "$ref": "#/components/schemas/PolicyBase"
          },
          {
            "type": "object",
            "description": "A PolicySet is an aggregation of PolicyRules or PolicySets combined according to provided algorithm",
            "properties": {
              "@type": {
                "type": "string"
              },
              "combiningAlgorithm": {
                "type": "string",
                "description": "defines a procedure for arriving at the result given the individual results of PolicyRule evaluations: \n * DenyOverrides - if a Policy element is encountered that evaluates to DENY, then, regardless of the evaluation result of the other Policy elements, the combined result is DENY. \n * PermitOverrides - if a Policy element is encountered that evaluates to PERMIT, then, regardless of the evaluation result of the other Policy elements, the combined result is PERMIT. \n * FirstApplicable - the combined result is the same as the result of successfull evaluating the first Policy. \n * OnlyOneApplicable - The result of this combining algorithm ensures that one and only one Policy is applicable by virtue of their targets.  If no Policy applies, then the result is NOT_APPLICABLE, but if more than one Policy is applicable, then the result is INDETERMINATE.  When exactly one Policy is applicable, the result of the combining algorithm is the result of that Policy. \n * DenyUnlessPermit - intended for those cases where a PERMIT decision should have priority over a DENY decision, and an INDETERMINATE or NOT_APPLICABLE must never be the result. \n * PermitUnlessDeny - intended for those cases where a DENY decision should have priority over a PERMIT decision, and an INDETERMINATE or NOT_APPLICABLE must never be the result.",
                "enum": [
                  "DenyOverrides",
                  "PermitOverrides",
                  "FirstApplicable",
                  "OnlyOneApplicable",
                  "DenyUnlessPermit",
                  "PermitUnlessDeny"
                ]
              },
              "policyRelationship": {
                "type": "array",
                "description": "List of all Policies that need to be executed",
                "items": {
                  "$ref": "#/components/schemas/PolicyRelationship"
                },
                "minItems": 1
              }
            }
          }
        ]
      },
      "PolicyRule": {
        "allOf": [
          {
            "$ref": "#/components/schemas/PolicyBase"
          },
          {
            "type": "object",
            "description": "A PolicyRule is an intelligent data container. It contains data that define how the PolicyRule is used in a managed environment as well as a specification of behavior that dictates how the managed entities that it applies to will interact. The contained data is of four types: \n * data and metadata that define the semantics and behavior of the policy rule and the behavior that it imposes on the rest of the system,\n * a group of events that can be used to trigger the evaluation of the condition clause of a policy rule,\n * a group of conditions aggregated by the PolicyRule,\n * group of actions aggregated by the PolicyRule.",
            "properties": {
              "@type": {
                "type": "string"
              },
              "targetPolicyEffect": {
                "type": "string",
                "description": "If underlying PolicyCondition resolves to TRUE, denotes target effect of a PolicyRule. If PolicyCondition is not resolved, then Policy effect is marked INDETERMINATE. If Policy is not run at all (because of Policy Constraints), then Policy effect is marked NOT_APPLICABLE.",
                "enum": [
                  "Permit",
                  "Deny"
                ]
              },
              "policyConditionRefOrValue": {
                "$ref": "#/components/schemas/PolicyConditionRefOrValue"
              }
            }
          }
        ]
      },
      "PolicyBase": {
        "description": "A superclass (set of shared properties) inherited by PolicyRule and PolicySet.",
        "properties": {
          "actionExecutionStrategy": {
            "type": "string",
            "description": "executionStrategy attribute defines the strategy to be used when executing the sequenced actions aggregated by this Policy",
            "enum": [
              "DoUntilSuccess",
              "DoAll",
              "DoUntilFailure",
              "DoAllWithoutFailureOrDoNothing"
            ],
            "default": "DoAll"
          },
          "sequencedActions": {
            "type": "string",
            "description": "Defines how the ordering of the PolicyActions associated with this Policy is to be interpreted.",
            "enum": [
              "Mandatory",
              "Recommended",
              "BestEffort"
            ],
            "default": "Mandatory"
          },
          "priority": {
            "type": "integer",
            "description": "Policy sequence value when Policy has to be executed in a specific order. Higher value means greater priority. Priority is not absolute, but relative in hierarchy. If a Policy is part of a PolicySet, priority on PolicySet overrides this priority",
            "default": 0
          },
          "policyDomainRef": {
            "type": "array",
            "description": "List of all Policy Domains for which this Policy is applicable",
            "items": {
              "$ref": "#/components/schemas/Reference"
            }
          },
          "policyEventRelationship": {
            "type": "array",
            "description": "List of all Policy Events for which this Policy is triggered",
            "items": {
              "$ref": "#/components/schemas/PolicyEventRelationship"
            },
            "minItems": 1
          },
          "policyActionRelationship": {
            "type": "array",
            "description": "List of all Policy Actions which are executed when this Policy is processed",
            "items": {
              "$ref": "#/components/schemas/PolicyActionRelationship"
            },
            "minItems": 1
          }
        }
      },
      "PolicyConditionRefOrValue": {
        "type": "object",
        "description": "Container for PolicyCondition Reference or unmanaged PolicyCondition object",
        "oneOf": [
          {
            "$ref": "#/components/schemas/PolicyConditionRef"
          },
          {
            "$ref": "#/components/schemas/PolicyCondition"
          }
        ],
        "discriminator": {
          "propertyName": "@type",
          "mapping": {
            "PolicyConditionRef": "#/components/schemas/PolicyConditionRef",
            "PolicyCondition": "#/components/schemas/PolicyCondition",
            "ManagedPolicyCondition": "#/components/schemas/ManagedPolicyCondition"
          }
        }
      },
      "ManagedPolicyCondition": {
        "description": "Managed PolicyCondition",
        "allOf": [
          {
            "$ref": "#/components/schemas/PolicyManagedEntity"
          },
          {
            "$ref": "#/components/schemas/PolicyCondition"
          }
        ],
        "discriminator": {
          "propertyName": "@type",
          "mapping": {
            "ManagedPolicyCondition": "#/components/schemas/ManagedPolicyCondition"
          }
        }
      },
      "PolicyCondition": {
        "type": "object",
        "description": "A PolicyCondition clause is an aggregation of individual PolicyConditions, and is treated as an atomic object that is aggregated by a PolicyRule. It is represented as a Boolean expression, and defines the necessary state and/or prerequisites that define whether the actions aggregated by that same PolicyRule should be performed. If PolicyCondition is successfully resolved then it must hold value TRUE or FALSE. Non successfull resolution does not contain any boolean value",
        "oneOf": [
          {
            "$ref": "#/components/schemas/PolicyConditionAtomic"
          },
          {
            "$ref": "#/components/schemas/PolicyConditionComposite"
          }
        ],
        "discriminator": {
          "propertyName": "@type",
          "mapping": {
            "PolicyConditionAtomic": "#/components/schemas/PolicyConditionAtomic",
            "PolicyConditionComposite": "#/components/schemas/PolicyConditionComposite"
          }
        }
      },
      "PolicyConditionAtomic": {
        "type": "object",
        "description": "PolicyCondition that executes only one statement",
        "properties": {
          "@type": {
            "type": "string"
          },
          "isResultNegated": {
            "type": "boolean",
            "default": "false"
          },
          "statement": {
            "$ref": "#/components/schemas/PolicyStatement"
          }
        }
      },
      "PolicyConditionComposite": {
        "type": "object",
        "description": "PolicyCondition that executes one or many PolicyConditions, applying condition combination logic",
        "properties": {
          "@type": {
            "type": "string"
          },
          "condition": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/PolicyConditionRefOrValue"
            },
            "minItems": 1
          },
          "conditionCombinationLogic": {
            "type": "string",
            "description": "Following combination logic is applied: \n * anyOf - if ANY condition resolves to TRUE, end result is TRUE \n * allOf - if ALL conditions resolves to TRUE, end result is TRUE \n * oneOf - if exactly ONE condition resolves to TRUE, end result is TRUE \n * none - if NONE condition resolves to TRUE, end result is TRUE",
            "enum": [
              "anyOf",
              "allOf",
              "oneOf",
              "none"
            ]
          },
          "isResultNegated": {
            "type": "boolean",
            "default": "false"
          }
        }
      },
      "PolicyConditionRef": {
        "allOf": [
          {
            "$ref": "#/components/schemas/Reference"
          },
          {
            "type": "object",
            "description": "Reference to managed PolicyCondition object",
            "properties": {
              "@type": {
                "type": "string"
              }
            }
          }
        ]
      },
      "PolicyStatement": {
        "type": "object",
        "description": "PolicyStatement is a definition of a: \n * query statement that resolves to boolean value or \n * command statement that is changing a value",
        "oneOf": [
          {
            "$ref": "#/components/schemas/PolicyOperatorRefOrValue"
          },
          {
            "$ref": "#/components/schemas/PolicyExpressionRefOrValue"
          }
        ],
        "discriminator": {
          "propertyName": "@type",
          "mapping": {
            "PolicyOperatorRefOrValue": "#/components/schemas/PolicyOperatorRefOrValue",
            "PolicyExpressionRefOrValue": "#/components/schemas/PolicyExpressionRefOrValue"
          }
        }
      },
"PolicyActionRelationship": {
        "type": "object",
        "description": "Contains details of a PolicyActionRelationship",
        "properties": {
          "priority": {
            "type": "integer",
            "description": "Sequence value when PolicyEvent has to be executed in a specific order. Higher value means greater priority. Priority is not absolute, but relative in hierarchy.",
            "default": 0
          },
          "constraint": {
            "$ref": "#/components/schemas/PolicyConstraintRefOrValue"
          },
          "policyActionRefOrValue": {
            "$ref": "#/components/schemas/PolicyActionRefOrValue"
          }
        }
      },

      
      "ManagedPolicyAction": {
        "description": "Managed PolicyAction",
        "allOf": [
          {
            "$ref": "#/components/schemas/PolicyManagedEntity"
          },
          {
            "$ref": "#/components/schemas/PolicyAction"
          }
        ],
        "discriminator": {
          "propertyName": "@type",
          "mapping": {
            "ManagedPolicyAction": "#/components/schemas/ManagedPolicyAction"
          }
        }
      },
      
      "ManagedPolicyConstraint": {
        "description": "Managed PolicyConstraint",
        "allOf": [
          {
            "$ref": "#/components/schemas/PolicyManagedEntity"
          },
          {
            "$ref": "#/components/schemas/PolicyConstraint"
          }
        ],
        "discriminator": {
          "propertyName": "@type",
          "mapping": {
            "ManagedPolicyConstraint": "#/components/schemas/ManagedPolicyConstraint"
          }
        }
      },
      "ManagedPolicyExpression": {
        "description": "Managed PolicyExpression",
        "allOf": [
          {
            "$ref": "#/components/schemas/PolicyManagedEntity"
          },
          {
            "$ref": "#/components/schemas/PolicyExpression"
          }
        ],
        "discriminator": {
          "propertyName": "@type",
          "mapping": {
            "ManagedPolicyExpression": "#/components/schemas/ManagedPolicyExpression"
          }
        }
      },
      "ManagedPolicyOperator": {
        "description": "Managed PolicyOperator",
        "allOf": [
          {
            "$ref": "#/components/schemas/PolicyManagedEntity"
          },
          {
            "$ref": "#/components/schemas/PolicyOperator"
          }
        ],
        "discriminator": {
          "propertyName": "@type",
          "mapping": {
            "ManagedPolicyOperator": "#/components/schemas/ManagedPolicyOperator"
          }
        }
      },
      "ManagedPolicyVariable": {
        "description": "Managed PolicyVariable",
        "allOf": [
          {
            "$ref": "#/components/schemas/PolicyManagedEntity"
          },
          {
            "$ref": "#/components/schemas/PolicyVariable"
          }
        ],
        "discriminator": {
          "propertyName": "@type",
          "mapping": {
            "ManagedPolicyVariable": "#/components/schemas/ManagedPolicyVariable"
          }
        }
      },
      
      "PolicyAction": {
        "type": "object",
        "description": "",
        "oneOf": [
          {
            "$ref": "#/components/schemas/PolicyActionAtomic"
          },
          {
            "$ref": "#/components/schemas/PolicyActionComposite"
          }
        ],
        "discriminator": {
          "propertyName": "@type",
          "mapping": {
            "PolicyActionAtomic": "#/components/schemas/PolicyActionAtomic",
            "PolicyActionComposite": "#/components/schemas/PolicyActionComposite"
          }
        }
      },
      "PolicyActionAtomic": {
        "allOf": [
          {
            "$ref": "#/components/schemas/PolicyActionBase"
          },
          {
            "description": "",
            "properties": {
              "@type": {
                "type": "string"
              },
              "action": {
                "$ref": "#/components/schemas/PolicyStatement"
              }
            }
          }
        ]
      },
      "PolicyOperatorRefOrValue": {
        "type": "object",
        "description": "Container for PolicyOperator Reference or unmanaged PolicyOperator object",
        "oneOf": [
          {
            "$ref": "#/components/schemas/PolicyOperatorRef"
          },
          {
            "$ref": "#/components/schemas/PolicyOperator"
          }
        ],
        "discriminator": {
          "propertyName": "@type",
          "mapping": {
            "PolicyOperatorRef": "#/components/schemas/PolicyOperatorRef",
            "PolicyOperator": "#/components/schemas/PolicyOperator",
            "ManagedPolicyOperator": "#/components/schemas/ManagedPolicyOperator"
          }
        }
      },
      "PolicyActionBase": {
        "description": "A superclass (set of shared properties) inherited by PolicyActionAtomic and PolicyActionComposite.",
        "properties": {
          "constraint": {
            "$ref": "#/components/schemas/PolicyConstraintRefOrValue"
          },
          "executedAt": {
            "type": "array",
            "description": "Defines when will this action be triggered, before Policy calculation, or after what calculated PolicyEffect",
            "items": {
              "type": "string",
              "enum": [
                "beforeAll",
                "beforePolicy",
                "onPermit",
                "onDeny",
                "onIndeterminate",
                "onResolved",
                "always",
                "afterAll"
              ]
            }
          }
        }
      },
      "PolicyActionComposite": {
        "allOf": [
          {
            "$ref": "#/components/schemas/PolicyActionBase"
          },
          {
            "description": "",
            "properties": {
              "@type": {
                "type": "string"
              },
              "action": {
                "type": "array",
                "items": {
                  "$ref": "#/components/schemas/PolicyActionRelationship"
                },
                "minItems": 1
              }
            }
          }
        ]
      },
      "PolicyActionRef": {
        "allOf": [
          {
            "$ref": "#/components/schemas/Reference"
          },
          {
            "type": "object",
            "description": "Reference to PolicyAction object",
            "properties": {
              "@type": {
                "type": "string"
              }
            }
          }
        ]
      },
      "PolicyActionRefOrValue": {
        "type": "object",
        "description": "Container for PolicyAction Reference or unmanaged PolicyAction object",
        "oneOf": [
          {
            "$ref": "#/components/schemas/PolicyActionRef"
          },
          {
            "$ref": "#/components/schemas/PolicyAction"
          }
        ],
        "discriminator": {
          "propertyName": "@type",
          "mapping": {
            "PolicyActionRef": "#/components/schemas/PolicyActionRef",
            "PolicyAction": "#/components/schemas/PolicyAction",
            "ManagedPolicyAction": "#/components/schemas/ManagedPolicyAction"
          }
        }
      },
      
      
      "PolicyCatalog": {
        "allOf": [
          {
            "$ref": "#/components/schemas/PolicyManagedEntity"
          },
          {
            "description": "A logical container of all Policy entites. Used to extract Policy details and provide it to the Policy Execution engine",
            "properties": {
              "policyDomainFilter": {
                "type": "array",
                "items": {
                  "$ref": "#/components/schemas/Reference"
                }
              },
              "policy": {
                "type": "array",
                "items": {
                  "$ref": "#/components/schemas/ManagedPolicy"
                }
              },
              "policyEvent": {
                "type": "array",
                "items": {
                  "$ref": "#/components/schemas/ManagedPolicyEvent"
                }
              },
              "policyCondition": {
                "type": "array",
                "items": {
                  "$ref": "#/components/schemas/ManagedPolicyCondition"
                }
              },
              "policyExpression": {
                "type": "array",
                "items": {
                  "$ref": "#/components/schemas/ManagedPolicyExpression"
                }
              },
              "policyOperator": {
                "type": "array",
                "items": {
                  "$ref": "#/components/schemas/ManagedPolicyOperator"
                }
              },
              "policyVariable": {
                "type": "array",
                "items": {
                  "$ref": "#/components/schemas/ManagedPolicyVariable"
                }
              },
              "policyAction": {
                "type": "array",
                "items": {
                  "$ref": "#/components/schemas/ManagedPolicyAction"
                }
              },
              "policyConstraint": {
                "type": "array",
                "items": {
                  "$ref": "#/components/schemas/ManagedPolicyConstraint"
                }
              }
            }
          }
        ],
        "discriminator": {
          "propertyName": "@type",
          "mapping": {
            "PolicyCatalog": "#/components/schemas/PolicyCatalog"
          }
        }
      },
      
      
      "PolicyConstraint": {
        "description": "Any kind of condition that needs to be confirmed in order to proceed with next step",
        "oneOf": [
          {
            "$ref": "#/components/schemas/PolicyEventConstraint"
          },
          {
            "$ref": "#/components/schemas/PolicyCondition"
          }
        ],
        "discriminator": {
          "propertyName": "@type",
          "mapping": {
            "PolicyEventConstraint": "#/components/schemas/PolicyEventConstraint",
            "PolicyCondition": "#/components/schemas/PolicyCondition",
            "ManagedPolicyCondition": "#/components/schemas/ManagedPolicyCondition"
          }
        }
      },
      "PolicyConstraintRef": {
        "allOf": [
          {
            "$ref": "#/components/schemas/Reference"
          },
          {
            "type": "object",
            "description": "Reference to managed PolicyConstraint object",
            "properties": {
              "@type": {
                "type": "string"
              }
            }
          }
        ]
      },
      "PolicyConstraintRefOrValue": {
        "type": "object",
        "description": "Container for PolicyConstraint Reference or unmanaged PolicyConstraint object",
        "oneOf": [
          {
            "$ref": "#/components/schemas/PolicyConstraintRef"
          },
          {
            "$ref": "#/components/schemas/PolicyConstraint"
          }
        ],
        "discriminator": {
          "propertyName": "@type",
          "mapping": {
            "PolicyConstraintRef": "#/components/schemas/PolicyConstraintRef",
            "PolicyConstraint": "#/components/schemas/PolicyConstraint",
            "ManagedPolicyConstraint": "#/components/schemas/ManagedPolicyConstraint"
          }
        }
      },
      "PolicyDomain": {
        "allOf": [
          {
            "$ref": "#/components/schemas/PolicyManagedEntity"
          },
          {
            "description": "",
            "properties": {
              "scopedManagedEntity": {
                "type": "array",
                "description": "List of entities to which this PolicyDomain applies",
                "items": {
                  "$ref": "#/components/schemas/Reference"
                },
                "minItems": 1
              },
              "subDomainRef": {
                "type": "array",
                "description": "List of child PolicyDomains. PolicyDomain can have many child Policy Domains, but one child PolicyDomain can only have one parent PolicyDomain",
                "items": {
                  "$ref": "#/components/schemas/Reference"
                }
              }
            }
          }
        ],
        "discriminator": {
          "propertyName": "@type",
          "mapping": {
            "PolicyDomain": "#/components/schemas/PolicyDomain"
          }
        }
      },
      "PolicyEvent": {
        "type": "object",
        "description": "A PolicyEvent is an occurrence of an important event or multiple events, and can be used to trigger the evaluation of a Policy",
        "oneOf": [
          {
            "$ref": "#/components/schemas/PolicyEventAtomicBase"
          },
          {
            "$ref": "#/components/schemas/PolicyEventComposite"
          }
        ],
        "discriminator": {
          "propertyName": "@type",
          "mapping": {
            "PolicyEventAtomicBase": "#/components/schemas/PolicyEventAtomicBase",
            "PolicyEventComposite": "#/components/schemas/PolicyEventComposite"
          }
        }
      },
      "PolicyEventAtomicBase": {
        "additionalProperties": true,
        "type": "object",
        "description": "A PolicyEventAtomic is an occurrence of a single atomic event. It must be used as a abstract class overloaded by a particular event in TMF API domain for which Policy is defined"
      },
      "PolicyEventComposite": {
        "type": "object",
        "description": "A PolicyEventComposite is an event made of multiple PolicyEvents.",
        "properties": {
          "@type": {
            "type": "string"
          },
          "policyEventRelationship": {
            "type": "array",
            "description": "Contains set of aggregated PolicyEvents",
            "items": {
              "$ref": "#/components/schemas/PolicyEventRelationship"
            },
            "minItems": 1
          }
        }
      },
      "PolicyEventConstraint": {
        "description": "Constraint based on provided list of PolicyEvent references. If PolicyEvent type is found in the list then constraint is validated truthfully",
        "properties": {
          "@type": {
            "type": "string"
          },
          "policyEventType": {
            "type": "array",
            "description": "List of PolicyEvent types",
            "items": {
              "type": "string"
            },
            "minItems": 1
          }
        }
      },
      "PolicyEventRef": {
        "type": "object",
        "description": "Reference to PolicyEvent object",
        "properties": {
          "@type": {
            "type": "string"
          },
          "@referredType": {
            "type": "string",
            "description": "The actual type of the target instance when needed for disambiguation."
          }
        }
      },
      "PolicyEventRefOrValue": {
        "type": "object",
        "description": "Container for PolicyEvent Reference or PolicyEvent object",
        "oneOf": [
          {
            "$ref": "#/components/schemas/PolicyEventRef"
          },
          {
            "$ref": "#/components/schemas/PolicyEvent"
          }
        ],
        "discriminator": {
          "propertyName": "@type",
          "mapping": {
            "PolicyEventRef": "#/components/schemas/PolicyEventRef",
            "PolicyEvent": "#/components/schemas/PolicyEvent",
            "ManagedPolicyEvent": "#/components/schemas/ManagedPolicyEvent"
          }
        }
      },
      "PolicyEventRelationship": {
        "type": "object",
        "description": "Contains details of a PolicyEventRelationship",
        "properties": {
          "priority": {
            "type": "integer",
            "description": "Sequence value when PolicyEvent has to be executed in a specific order. Higher value means greater priority. Priority is not absolute, but relative in hierarchy.",
            "default": 0
          },
          "constraint": {
            "$ref": "#/components/schemas/PolicyConstraintRefOrValue"
          },
          "policyEventRefOrValue": {
            "$ref": "#/components/schemas/PolicyEventRefOrValue"
          }
        }
      },
      "PolicyExpression": {
        "type": "object",
        "description": "PolicyExpression is a constraint based on text expression and parsed by an Expression Language (SpEL, JS, Groovy, FEEL, ...)",
        "properties": {
          "@type": {
            "type": "string"
          },
          "expression": {
            "type": "string",
            "description": "Expression language command"
          },
          "expressionLanguage": {
            "description": "Defines expression language used to build expression",
            "type": "string",
            "example": "JS"
          }
        }
      },
      "PolicyExpressionRef": {
        "allOf": [
          {
            "$ref": "#/components/schemas/Reference"
          },
          {
            "type": "object",
            "description": "Reference to managed PolicyExpression object",
            "properties": {
              "@type": {
                "type": "string"
              }
            }
          }
        ]
      },
      "PolicyExpressionRefOrValue": {
        "type": "object",
        "description": "Container for PolicyExpression Reference or unmanaged PolicyExpression object",
        "oneOf": [
          {
            "$ref": "#/components/schemas/PolicyExpressionRef"
          },
          {
            "$ref": "#/components/schemas/PolicyExpression"
          }
        ],
        "discriminator": {
          "propertyName": "@type",
          "mapping": {
            "PolicyExpressionRef": "#/components/schemas/PolicyExpressionRef",
            "PolicyExpression": "#/components/schemas/PolicyExpression",
            "ManagedPolicyExpression": "#/components/schemas/ManagedPolicyExpression"
          }
        }
      },
      
      "PolicyOperator": {
        "allOf": [
          {
            "$ref": "#/components/schemas/Extensible"
          },
          {
            "type": "object",
            "description": "A PolicyOperator is a class that defines possible operations with needed operands on a specific variables",
            "properties": {
              "variable": {
                "$ref": "#/components/schemas/PolicyVariableRefOrValue"
              }
            }
          }
        ],
        "discriminator": {
          "propertyName": "@type",
          "mapping": {
            "PolicyOperator": "#/components/schemas/PolicyOperator",
            "ManagedPolicyOperator": "#/components/schemas/ManagedPolicyOperator"
          }
        }
      },
      "PolicyOperatorRef": {
        "allOf": [
          {
            "$ref": "#/components/schemas/Reference"
          },
          {
            "type": "object",
            "description": "Reference to managed PolicyOperator object",
            "properties": {
              "@type": {
                "type": "string"
              }
            }
          }
        ]
      },
      
      "PolicyRef": {
        "allOf": [
          {
            "$ref": "#/components/schemas/Reference"
          },
          {
            "type": "object",
            "description": "Reference to managed Policy object",
            "properties": {
              "id": {
                "type": "string",
                "description": "unique identifier"
              },
              "href": {
                "type": "string",
                "description": "Hyperlink reference"
              },
              "version": {
                "type": "string"
              },
              "@type": {
                "type": "string",
                "description": "When sub-classing, this defines the sub-class Extensible name"
              },
              "@baseType": {
                "type": "string",
                "description": "When sub-classing, this defines the super-class"
              },
              "@schemaLocation": {
                "type": "string",
                "description": "A URI to a JSON-Schema file that defines additional attributes and relationships"
              }
            }
          }
        ]
      },
      "PolicyRefOrValue": {
        "type": "object",
        "description": "Container for Policy Reference or unmanaged Policy object",
        "oneOf": [
          {
            "$ref": "#/components/schemas/PolicyRef"
          },
          {
            "$ref": "#/components/schemas/Policy"
          }
        ],
        "discriminator": {
          "propertyName": "@type",
          "mapping": {
            "PolicyRef": "#/components/schemas/PolicyRef",
            "Policy": "#/components/schemas/Policy",
            "ManagedPolicy": "#/components/schemas/ManagedPolicy"
          }
        }
      },
      "PolicyRelationship": {
        "type": "object",
        "description": "Contains details of a PolicyRelationship",
        "properties": {
          "priority": {
            "type": "integer",
            "description": "Policy sequence value when Policy has to be executed in a specific order. Higher value means greater priority. Priority is not absolute, but relative in hierarchy.",
            "default": 0
          },
          "constraint": {
            "$ref": "#/components/schemas/PolicyConstraintRefOrValue"
          },
          "policyRefOrValue": {
            "$ref": "#/components/schemas/PolicyRefOrValue"
          }
        }
      },
      
      
      
      "PolicyVariable": {
        "type": "object",
        "description": "A PolicyVariable is an entity for modeling different types of variables that can be used to form a PolicyCondition statement. It can be static or dynamic.",
        "oneOf": [
          {
            "$ref": "#/components/schemas/PolicyVariableDynamic"
          },
          {
            "$ref": "#/components/schemas/PolicyVariableStatic"
          }
        ],
        "discriminator": {
          "propertyName": "@type",
          "mapping": {
            "PolicyVariableDynamic": "#/components/schemas/PolicyVariableDynamic",
            "PolicyVariableStatic": "#/components/schemas/PolicyVariableStatic"
          }
        }
      },
      "PolicyVariableDynamic": {
        "type": "object",
        "description": "A PolicyVariableDynamic is a variable that is resolved from event, environment or subject",
        "properties": {
          "@type": {
            "type": "string"
          },
          "valueType": {
            "type": "string",
            "enum": [
              "string",
              "number",
              "integer",
              "boolean",
              "object",
              "array"
            ]
          },
          "format": {
            "type": "string"
          },
          "resolver": {
            "type": "array",
            "description": "Specification of a varaible resolver",
            "items": {
              "$ref": "#/components/schemas/PolicyVariableResolver"
            },
            "minItems": 1
          }
        }
      },
      "PolicyVariableRef": {
        "allOf": [
          {
            "$ref": "#/components/schemas/Reference"
          },
          {
            "type": "object",
            "description": "Reference to managed PolicyVariable object",
            "properties": {
              "@type": {
                "type": "string"
              }
            }
          }
        ]
      },
      "PolicyVariableRefOrValue": {
        "type": "object",
        "description": "Container for PolicyVariable Reference or unmanaged PolicyVariable object",
        "oneOf": [
          {
            "$ref": "#/components/schemas/PolicyVariableRef"
          },
          {
            "$ref": "#/components/schemas/PolicyVariable"
          }
        ],
        "discriminator": {
          "propertyName": "@type",
          "mapping": {
            "PolicyVariableRef": "#/components/schemas/PolicyVariableRef",
            "PolicyVariable": "#/components/schemas/PolicyVariable",
            "ManagedPolicyVariable": "#/components/schemas/ManagedPolicyVariable"
          }
        }
      },
      "PolicyVariableResolver": {
        "type": "object",
        "description": "A PolicyVariableResolver is a definition that describes from where is DynamicVariable fetched",
        "properties": {
          "@type": {
            "type": "string"
          },
          "source": {
            "type": "string",
            "enum": [
              "event",
              "environment",
              "subject",
              "result"
            ]
          },
          "path": {
            "description": "JSONPath of a variable",
            "type": "string"
          },
          "priority": {
            "type": "integer",
            "description": "Sequence value when PolicyVariableResolver has to be executed in a specific order. Higher value means greater priority. Priority is not absolute, but relative in hierarchy.",
            "default": 0
          },
          "constraint": {
            "$ref": "#/components/schemas/PolicyConstraintRefOrValue"
          }
        }
      },
      "PolicyVariableStatic": {
        "type": "object",
        "description": "A PolicyVariableStatic is a variable that is ",
        "properties": {
          "@type": {
            "type": "string"
          },
          "valueType": {
            "type": "string",
            "enum": [
              "string",
              "number",
              "integer",
              "boolean",
              "object",
              "array"
            ]
          },
          "format": {
            "type": "string"
          },
          "value": {
            "$ref": "#/components/schemas/AnyValue"
          }
        }
      }
    }
  }
}
